<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gemini Yoga Flow Generator</title>
  <link rel="stylesheet" href="/css/stylesheet.css">
</head>
<body>

<div class="input_container">
  <h2>Choose Poses:</h2>
  <div id="pose_options"></div>

  <h2>Choose Target Areas:</h2>
  <div id="target_options"></div>

  <h2>Sequence Name:</h2>
  <input type="text" id="queue_name" placeholder="Enter a name for your sequence">

  <button id="submit_query">Generate Sequence</button>
  <button id="regenerate_query" disabled>Regenerate Flow</button>
  <button id="clear_query">Clear Selection</button>
  <button id="save_query" disabled>Save Flow</button>
</div>

<div id="results_container"></div>

<script>
    // DEBUG flag
    let DEBUG = false;

    // Variable declaration (stuff getter)
    const pose_options_div = document.getElementById('pose_options');
    const target_options_div = document.getElementById('target_options');
    const submit_query_button = document.getElementById('submit_query');
    const regenerate_query_button = document.getElementById('regenerate_query');
    const clear_query_button = document.getElementById('clear_query');
    const save_query_button = document.getElementById('save_query');
    const results_container = document.getElementById('results_container');
    const queue_name_input = document.getElementById('queue_name');

    // Arrays that will help us display and build out query
    let generated_pose_names = []; // All the poses we support
    let last_selected_names = []; // All of the poses the user selects
    let last_selected_targets = []; // All of the target areas user selects
    let cooldown_timer = null; // We need a timer for Gemini throttling
    // TODO_BUG: Can technically refresh and hit a snag.
    let cooldown_seconds = 45; // Set to 45 second (we are allowed 3 queries a min).

    // This function will handle populating the poses as checkboxes
    async function fetch_options() {
        try {
            // Alright, lets get the response from the 
            const response = await fetch('api_handler.php?endpoint=options');
            if (DEBUG) console.log(response);
            const data = await response.json();
            if (DEBUG) console.log(data);

            // Now that we have the data in json format, lets take the name and build
            // out our checkboxes iteratively
            data.english_names.forEach(name => {
                const label = document.createElement('label');
                label.innerHTML = `<input type="checkbox" class="pose_checkbox" value="${name}"> ${name}`;
                pose_options_div.appendChild(label);
                pose_options_div.appendChild(document.createElement('br'));
            });

            // Lets now build our the checkboxes for target areas
            data.targets.forEach(target => {
                const label = document.createElement('label');
                label.innerHTML = `<input type="checkbox" class="target_checkbox" value="${target}"> ${target}`;
                target_options_div.appendChild(label);
                target_options_div.appendChild(document.createElement('br'));
            });
        } catch (error) {
            console.error('Failed to fetch options:', error);
        }
    }

    // This function will help us control how quickly user can regenerate a gemini
    // query. https://ai.google.dev/gemini-api/docs/troubleshooting
    function start_cooldown() {

        //Lets use these flags to keep track of whether these events have been hit
        submit_query_button.disabled = true;
        regenerate_query_button.disabled = true;

        // Lets remove it if it exists already so we can start off fresh each time
        if (document.getElementById('cooldown_message')) {
            document.getElementById('cooldown_message').remove();
        }

        // Now lets create the cooldown message
        const cooldown_msg = document.createElement('p');
        cooldown_msg.id = 'cooldown_message';
        cooldown_msg.style.color = 'orange';
        cooldown_msg.style.fontStyle = 'italic';
        cooldown_msg.textContent = `Gemini Cooldown: Please wait ${cooldown_seconds} seconds...`;
        results_container.appendChild(cooldown_msg);

        // Alright lets now display how many seconds we have left on the message until we
        // can requery https://www.w3schools.com/js/js_timing.asp
        let seconds_left = cooldown_seconds;
        cooldown_timer = setInterval(() => {
            seconds_left--;

            if (seconds_left > 0) {
                const message_element = document.getElementById('cooldown_message');
                if (message_element) {
                    message_element.textContent = `Query Cooldown: Please wait ${seconds_left} seconds...`;
                }
            } else { // We have finished timer, lets re-enable our buttons
                clearInterval(cooldown_timer);
                submit_query_button.disabled = false;
                regenerate_query_button.disabled = generated_pose_names.length > 0 ? false : true; // Have we already generated a flow using gemini?

                const message_element = document.getElementById('cooldown_message');
                if (message_element) {
                    message_element.textContent = `Cooldown ended! You can generate again.`;
                    message_element.style.color = 'green';
                    message_element.style.fontStyle = 'normal';
                }
            }
        }, 1000); // 1000 ms = 1 sec. 
    }

    // This function will handle packaging up our selections and sending it over to api_handler for querying
    async function send_query() {

        // Lets find all of the class pose_checkbox + target_checkbox that are checked and convert them into an array
        const selected_names = Array.from(document.querySelectorAll('.pose_checkbox:checked')).map(curr => curr.value);
        const selected_targets = Array.from(document.querySelectorAll('.target_checkbox:checked')).map(curr => curr.value);
        const queue_name = queue_name_input.value.trim();
        if (DEBUG) console.log(selected_names);
        if (DEBUG) console.log(selected_targets);
        if (DEBUG) console.log(queue_name);

        if ((selected_names.length === 0 && selected_targets.length === 0) || !queue_name) {
            results_container.textContent = 'Please select poses/targets and enter a sequence name.';
            return;
        }

        // Lets save the array in case user decides to regenerate
        last_selected_names = selected_names;
        last_selected_targets = selected_targets;

        // Okay now that we have all of the checked items, lets work on sending it to gemini
        try {
            
            // Lets post the payload over to our api_handler in the format it is expecting and wait
            const response = await fetch('api_handler.php?endpoint=generate-sequence', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ names: selected_names, targets: selected_targets, queue_name })
            });

            // Okay, gemini should have responded. Lets parse that bad boy.
            const data = await response.json();
            if (DEBUG) console.log(data);
            if (DEBUG) console.log(data.gemini); // Lets make sure gemini gave us proper response
            if (DEBUG) console.log(data.pose_names); // Lets make sure pose names are good

            // Cool lets now go into parsing assuming we got a successful response
            if (data.pose_names && data.gemini) {
                generated_pose_names = data.pose_names;

                // Lets make a div for where we will show the parsed output
                const sequence_div = document.createElement('div');
                sequence_div.innerHTML = `<h3>Generated Sequence:</h3><pre>${data.gemini}</pre><p>Sequence ready!</p>`;

                // Clear results but preserve cooldown if running (clone.Node allows us to make a deep copy)
                const cooldown_element = document.getElementById('cooldown_message');
                const cooldown_snapshot = cooldown_element ? cooldown_element.cloneNode(true) : null; // If it exists, deep copy. Else null.

                results_container.innerHTML = '';
                results_container.appendChild(sequence_div);

                // If the timer was running, lets restore it!
                if (cooldown_snapshot) {
                    results_container.appendChild(cooldown_snapshot);
                }

                // Now that we successfully created a query, lets enable the buttons for saving and regenerating
                save_query_button.disabled = false;
                regenerate_query_button.disabled = false;
                start_cooldown();
            } else {
                results_container.textContent = data.error || 'No sequence generated.';
            }
        } catch (error) {
            console.error('Error sending query:', error);
            results_container.textContent = `An error occurred: ${error.message}`;
        }
    }

    // This function will handle regenerating the query using gemini if user asks
    // for it
    async function regenerate_query() {
        
        //Lets grab the elements based off what we last selected
        // TODO BUG: Need to test what happens when user switches up selection and regenerate. We don't handle. 
        const queue_name = queue_name_input.value.trim();

        if (DEBUG) console.log(last_selected_names);
        if (DEBUG) console.log(last_selected_targets);
        if (DEBUG) console.log(queue_name);

        if ((last_selected_names.length === 0 && last_selected_targets.length === 0) || !queue_name) {
            results_container.textContent = 'No previous selection found. Please make a new selection.';
            return;
        }

        // Again, we hit gemini as before
        try {
            const response = await fetch('api_handler.php?endpoint=generate-sequence', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ names: last_selected_names, targets: last_selected_targets, queue_name })
            });

            const data = await response.json();
            if (DEBUG) console.log(response.json());

            if (data.pose_names && data.gemini) {
                generated_pose_names = data.pose_names;

                const sequence_div = document.createElement('div');
                sequence_div.innerHTML = `<h3>Regenerated Sequence:</h3><pre>${data.gemini}</pre><p>Sequence ready!</p>`;

                const cooldown_element = document.getElementById('cooldown_message');
                const cooldown_snapshot = cooldown_element ? cooldown_element.cloneNode(true) : null;

                results_container.innerHTML = '';
                results_container.appendChild(sequence_div);

                if (cooldown_snapshot) {
                    results_container.appendChild(cooldown_snapshot);
                }

                save_query_button.disabled = false;
                start_cooldown();
            } else {
                results_container.textContent = data.error || 'No sequence regenerated.';
            }
        } catch (error) {
            console.error('Error regenerating query:', error);
            results_container.textContent = `An error occurred: ${error.message}`;
        }
    }

    // This function will handle saving the flow we currently have presented to the user
    async function save_flow() {
        const queue_name = queue_name_input.value.trim();
        if (!queue_name || generated_pose_names.length === 0) {
            alert('No valid flow to save.');
            return;
        }

        try {
            // Lets save our flow to the database!
            const response = await fetch('api_handler.php?endpoint=save-sequence', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ queue_name, pose_names: generated_pose_names })
            });

            // Alright, lets make sure it worked!
            const data = await response.json();
            if (data.success) {
                results_container.innerHTML += `<p><strong>Sequence Saved Successfully!</strong></p>`;
                save_query_button.disabled = true;
            } else {
                results_container.textContent = data.error || 'Failed to save sequence.';
            }

            // Clear all selections after save
            document.querySelectorAll('.pose_checkbox, .target_checkbox').forEach(curr => curr.checked = false);

            // Clear input box
            queue_name_input.value = '';

            // Disable buttons
            save_query_button.disabled = true;
            regenerate_query_button.disabled = true;

            // Reset arrays
            generated_pose_names = [];
            last_selected_names = [];
            last_selected_targets = [];
        } catch (error) {
            console.error('Error saving flow:', error);
            results_container.textContent = `An error occurred: ${error.message}`;
        }
    }

    // Lets handle page reset
    clear_query_button.addEventListener('click', () => {
        // Uncheck all the boxes
        document.querySelectorAll('.pose_checkbox, .target_checkbox').forEach(curr => curr.checked = false);

        // Lets reset the cooldown timer
        const cooldown_element = document.getElementById('cooldown_message');
        const cooldown_snapshot = cooldown_element ? cooldown_element.cloneNode(true) : null;

        results_container.innerHTML = '';

        if (cooldown_snapshot) {
            results_container.appendChild(cooldown_snapshot);
        }

        // Reset all of our arrays and variables
        queue_name_input.value = '';
        save_query_button.disabled = true;
        regenerate_query_button.disabled = true;
        generated_pose_names = [];
        last_selected_names = [];
        last_selected_targets = [];
    });

    save_query_button.addEventListener('click', save_flow);
    submit_query_button.addEventListener('click', send_query);
    regenerate_query_button.addEventListener('click', regenerate_query);

    fetch_options();
</script>

</body>
</html>